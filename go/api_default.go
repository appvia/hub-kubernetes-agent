/*
 * hub-kubernetes-agent
 *
 * an agent used to provision and configure Kubernetes resources
 *
 * API version: v1beta
 * Contact: support@appvia.io
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"encoding/base64"
	"encoding/json"
	"log"
	"net/http"

	"github.com/bitly/go-simplejson"
	"github.com/gorilla/mux"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"

	errors "k8s.io/apimachinery/pkg/api/errors"
	v1 "k8s.io/client-go/pkg/api/v1"
	rbacv1alpha1 "k8s.io/client-go/pkg/apis/rbac/v1alpha1"
)

var clientset *kubernetes.Clientset

func getClient(server, token, caCert string) (*kubernetes.Clientset, error) {
	decodedCert, err := base64.StdEncoding.DecodeString(caCert)

	if err != nil {
		log.Println("decode error:", err)
		return nil, err
	}

	config := &rest.Config{
		Host:            server,
		BearerToken:     token,
		TLSClientConfig: rest.TLSClientConfig{CAData: decodedCert},
	}

	client, err := kubernetes.NewForConfig(config)
	_ = client

	if err != nil {
		return nil, err
	}

	return kubernetes.NewForConfig(config)
}

func handleSuccess(w http.ResponseWriter, payload []byte) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	w.Write(payload)
}

func handleInternalServerError(w http.ResponseWriter, reason string, err error) {
	log.Println(err.Error())
	json := simplejson.New()
	json.Set("reason", reason)
	json.Set("detail", err)
	payload, err := json.MarshalJSON()
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	http.Error(w, string(payload), http.StatusInternalServerError)
}

func handleNotFoundError(w http.ResponseWriter, err error) {
	log.Println(err.Error())
	json := simplejson.New()
	json.Set("reason", "not found")
	json.Set("detail", err)
	payload, err := json.MarshalJSON()
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	http.Error(w, string(payload), http.StatusNotFound)
}

func NamespacesList(w http.ResponseWriter, r *http.Request) {
	clientset, err := getClient(r.Header.Get("X-Kube-API-URL"), r.Header.Get("X-Kube-Token"), r.Header.Get("X-Kube-CA"))

	if err != nil {
		log.Println(err)
	}

	namespaces, err := clientset.CoreV1().Namespaces().List(v1.ListOptions{})

	if err != nil {
		handleInternalServerError(w, "error listing namespaces", err)
	} else {
		var namespaceList []Namespace
		for _, namespace := range namespaces.Items {
			namespaceList = append(namespaceList, Namespace{Name: namespace.Name})
		}
		payload, err := json.Marshal(namespaceList)
		if err != nil {
			log.Println(err)
		}
		handleSuccess(w, payload)
	}
}

func NamespacesNameGet(w http.ResponseWriter, r *http.Request) {
	clientset, err := getClient(r.Header.Get("X-Kube-API-URL"), r.Header.Get("X-Kube-Token"), r.Header.Get("X-Kube-CA"))

	vars := mux.Vars(r)
	name := vars["name"]
	namespace, err := clientset.CoreV1().Namespaces().Get(name)
	_ = namespace

	if err != nil {
		if errors.IsNotFound(err) {
			handleNotFoundError(w, err)
		} else {
			handleInternalServerError(w, "Error getting namespace", err)
		}
	} else {
		json := simplejson.New()
		json.Set("name", name)
		log.Printf("Found namespace: %s\n", name)
		payload, err := json.MarshalJSON()
		if err != nil {
			log.Println(err)
		}
		handleSuccess(w, payload)
	}
}

func NamespacesNameDelete(w http.ResponseWriter, r *http.Request) {
	clientset, err := getClient(r.Header.Get("X-Kube-API-URL"), r.Header.Get("X-Kube-Token"), r.Header.Get("X-Kube-CA"))

	if err != nil {
		log.Println(err)
	}

	vars := mux.Vars(r)
	name := vars["name"]

	json := simplejson.New()

	if err := clientset.CoreV1().Namespaces().Delete(name, &v1.DeleteOptions{}); errors.IsNotFound(err) || err == nil {
		json.Set("name", name)
		payload, err := json.MarshalJSON()
		if err != nil {
			log.Println(err)
		}
		log.Printf("Deleted namespace: %s\n", name)
		handleSuccess(w, payload)
	} else if err != nil {
		handleInternalServerError(w, "namespace not found", err)
	}
}

func NamespacesNamePut(w http.ResponseWriter, r *http.Request) {
	clientset, err := getClient(r.Header.Get("X-Kube-API-URL"), r.Header.Get("X-Kube-Token"), r.Header.Get("X-Kube-CA"))

	if err != nil {
		panic(err)
	}

	vars := mux.Vars(r)
	name := vars["name"]
	_ = name

	var n NamespaceSpec
	decoder := json.NewDecoder(r.Body)
	decoder.Decode(&n)

	namespaceName := n.Name
	namespaceServiceAccounts := n.ServiceAccounts

	log.Printf("Attempting to create namespace: %s", namespaceName)

	namespace, err := clientset.CoreV1().Namespaces().Create(&v1.Namespace{
		ObjectMeta: v1.ObjectMeta{
			Name: namespaceName,
		},
	})
	_ = namespace

	if errors.IsAlreadyExists(err) || err == nil {
		log.Printf("Namespace created")
	} else if err != nil {
		handleInternalServerError(w, "error creating namespace", err)
	}

	for _, sa := range namespaceServiceAccounts {
		subject := rbacv1alpha1.Subject{
			Kind:      "ServiceAccount",
			Name:      sa,
			Namespace: "default",
		}

		var subjects []rbacv1alpha1.Subject

		subjects = append(subjects, subject)

		roleRef := rbacv1alpha1.RoleRef{
			APIGroup: "rbac.authorization.k8s.io",
			Kind:     "ClusterRole",
			Name:     "cluster-admin",
		}

		roleBinding := rbacv1alpha1.RoleBinding{
			Subjects: subjects,
			RoleRef:  roleRef,
			ObjectMeta: v1.ObjectMeta{
				Name: sa + "-cluster-admin-" + namespaceName,
			},
		}

		roleBindingReponse, err := clientset.Rbac().RoleBindings(sa).Create(&roleBinding)
		_ = roleBindingReponse

		if errors.IsAlreadyExists(err) || err == nil {
			log.Printf("Created role binding: %s-cluster-admin-%s", sa, namespaceName)
		} else {
			log.Printf("Failed to create role binding: %s-cluster-admin-%s", sa, namespaceName)
			handleInternalServerError(w, "error creating rolebinding for namespace", err)
		}
	}
	json := simplejson.New()
	json.Set("name", namespaceName)
	payload, err := json.MarshalJSON()
	handleSuccess(w, payload)
}

func ServiceAccountsNamespaceGet(w http.ResponseWriter, r *http.Request) {
	clientset, err := getClient(r.Header.Get("X-Kube-API-URL"), r.Header.Get("X-Kube-Token"), r.Header.Get("X-Kube-CA"))

	vars := mux.Vars(r)
	namespace := vars["namespace"]

	if namespace == "" {
		namespace = "default"
	}
	namespaceCheck, err := clientset.CoreV1().Namespaces().Get(namespace)
	_ = namespaceCheck

	if errors.IsNotFound(err) {
		log.Printf("Namespace: %s not found\n", namespace)
		handleNotFoundError(w, err)
		return
	}

	serviceAccounts, err := clientset.CoreV1().ServiceAccounts(namespace).List(v1.ListOptions{})
	_ = serviceAccounts

	json := simplejson.New()

	if errors.IsNotFound(err) {
		log.Printf("Service account not found\n")
		handleNotFoundError(w, err)
	} else if err != nil {
		handleInternalServerError(w, "error getting service account", err)
	} else {
		var serviceAccountList []string
		for _, sa := range serviceAccounts.Items {
			serviceAccountList = append(serviceAccountList, sa.Name)
		}
		json.Set("service-accounts", serviceAccountList)
		payload, err := json.MarshalJSON()
		if err != nil {
			log.Println(err)
		}
		log.Printf("Listing service accounts for namespace: %s\n", namespace)
		handleSuccess(w, payload)
	}
}

func ServiceAccountsNamespaceNameDelete(w http.ResponseWriter, r *http.Request) {
	clientset, err := getClient(r.Header.Get("X-Kube-API-URL"), r.Header.Get("X-Kube-Token"), r.Header.Get("X-Kube-CA"))

	if err != nil {
		log.Println(err)
	}

	vars := mux.Vars(r)
	name := vars["name"]
	namespace := vars["namespace"]

	if namespace == "" {
		namespace = "default"
	}
	json := simplejson.New()

	if err := clientset.CoreV1().ServiceAccounts(namespace).Delete(name, &v1.DeleteOptions{}); errors.IsNotFound(err) || err == nil {
		json.Set("name", name)
		payload, err := json.MarshalJSON()
		if err != nil {
			log.Println(err)
		}
		log.Printf("Deleted service account: %s from namespace: %s\n", name, namespace)
		handleSuccess(w, payload)
	} else if err != nil {
		handleInternalServerError(w, "error deleting service account", err)
	}
}

func ServiceAccountsNamespaceNameGet(w http.ResponseWriter, r *http.Request) {
	clientset, err := getClient(r.Header.Get("X-Kube-API-URL"), r.Header.Get("X-Kube-Token"), r.Header.Get("X-Kube-CA"))

	vars := mux.Vars(r)
	name := vars["name"]
	namespace := vars["namespace"]

	if namespace == "" {
		namespace = "default"
	}

	serviceAccount, err := clientset.CoreV1().ServiceAccounts(namespace).Get(name)
	_ = serviceAccount

	json := simplejson.New()

	if errors.IsNotFound(err) {
		log.Printf("Service account %s not found\n", name)
		handleNotFoundError(w, err)
	} else if err != nil {
		handleInternalServerError(w, "error getting service account", err)
	} else {
		json.Set("name", name)
		secret, err := clientset.CoreV1().Secrets(namespace).Get(serviceAccount.Secrets[0].Name)
		if err != nil {
			log.Printf("Error getting service account token for %s\n", name)
			log.Println(err)
		} else {
			json.Set("token", string(secret.Data["token"]))
		}
		payload, err := json.MarshalJSON()
		if err != nil {
			log.Println(err)
		}
		log.Printf("Found service account: %s\n", name)
		handleSuccess(w, payload)
	}
}

func ServiceAccountsNamespaceNamePut(w http.ResponseWriter, r *http.Request) {
	clientset, err := getClient(r.Header.Get("X-Kube-API-URL"), r.Header.Get("X-Kube-Token"), r.Header.Get("X-Kube-CA"))

	vars := mux.Vars(r)
	name := vars["name"]
	namespace := vars["namespace"]

	serviceAccount, err := clientset.CoreV1().ServiceAccounts(namespace).Create(&v1.ServiceAccount{
		ObjectMeta: v1.ObjectMeta{
			Name: name,
		},
	})
	_ = serviceAccount

	json := simplejson.New()

	if errors.IsAlreadyExists(err) || err == nil {
		json.Set("name", name)
		if err != nil {
			log.Println(err)
		}
		serviceAccount, err := clientset.CoreV1().ServiceAccounts(namespace).Get(name)
		_ = serviceAccount
		secret, err := clientset.CoreV1().Secrets(namespace).Get(serviceAccount.Secrets[0].Name)
		if err != nil {
			log.Printf("Error getting service account token for %s\n", name)
			log.Println(err)
		} else {
			json.Set("token", string(secret.Data["token"]))
		}
		payload, err := json.MarshalJSON()
		log.Printf("Created service account: %s in namespace: %s\n", name, namespace)
		handleSuccess(w, payload)
	} else if err != nil {
		log.Println(err)
		handleInternalServerError(w, "error creating service account", err)
	}
}
