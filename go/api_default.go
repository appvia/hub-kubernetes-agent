/*
 * hub-kubernetes-agent
 *
 * an agent used to provision and configure Kubernetes resources
 *
 * API version: v1beta
 * Contact: support@appvia.io
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"encoding/base64"
	"encoding/json"
	"io/ioutil"
	"log"
	"net/http"

	"github.com/gorilla/mux"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/pkg/api/errors"
	"k8s.io/client-go/rest"

	v1 "k8s.io/client-go/pkg/api/v1"
	rbacv1alpha1 "k8s.io/client-go/pkg/apis/rbac/v1alpha1"
)

var clientset *kubernetes.Clientset

func getClient(server, token, caCert string) (*kubernetes.Clientset, error) {
	decodedCert, err := base64.StdEncoding.DecodeString(caCert)

	if err != nil {
		log.Println("decode error:", err)
		return nil, err
	}

	config := &rest.Config{
		Host:            server,
		BearerToken:     token,
		TLSClientConfig: rest.TLSClientConfig{CAData: decodedCert},
	}

	client, err := kubernetes.NewForConfig(config)
	_ = client

	if err != nil {
		return nil, err
	}

	return kubernetes.NewForConfig(config)
}

func handleSuccess(w http.ResponseWriter, payload []byte) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	w.Write(payload)
}

func handleInternalServerError(w http.ResponseWriter, reason string, err error) {
	log.Println(err.Error())
	var apiError ApiError
	apiError = ApiError{Reason: reason, Detail: err.Error()}
	payload, err := json.Marshal(apiError)
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	http.Error(w, string(payload), http.StatusInternalServerError)
}

func handleNotFoundError(w http.ResponseWriter, err error) {
	log.Println(err.Error())
	var apiError ApiError
	apiError = ApiError{Reason: "not found", Detail: err.Error()}
	payload, err := json.Marshal(apiError)
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	http.Error(w, string(payload), http.StatusNotFound)
}

func NamespacesList(w http.ResponseWriter, r *http.Request) {
	clientset, err := getClient(r.Header.Get("X-Kube-API-URL"), r.Header.Get("X-Kube-Token"), r.Header.Get("X-Kube-CA"))

	if err != nil {
		log.Println(err)
	}

	namespaces, err := clientset.CoreV1().Namespaces().List(v1.ListOptions{})

	if err != nil {
		handleInternalServerError(w, "error listing namespaces", err)
		return
	} else {
		var namespaceList []Namespace
		for _, namespace := range namespaces.Items {
			namespaceList = append(namespaceList, Namespace{Name: namespace.Name})
		}
		payload, err := json.Marshal(namespaceList)
		if err != nil {
			log.Println(err)
		}
		handleSuccess(w, payload)
		return
	}
}

func NamespacesNameGet(w http.ResponseWriter, r *http.Request) {
	clientset, err := getClient(r.Header.Get("X-Kube-API-URL"), r.Header.Get("X-Kube-Token"), r.Header.Get("X-Kube-CA"))

	vars := mux.Vars(r)
	name := vars["name"]
	namespace, err := clientset.CoreV1().Namespaces().Get(name)
	_ = namespace

	if err != nil {
		if errors.IsNotFound(err) {
			handleNotFoundError(w, err)
		} else {
			handleInternalServerError(w, "Error getting namespace", err)
		}
	} else {
		var namespaceItem Namespace
		namespaceItem = Namespace{Name: namespace.Name}
		payload, err := json.Marshal(namespaceItem)
		if err != nil {
			log.Println(err)
		}
		handleSuccess(w, payload)
		return
	}
}

func NamespacesNameDelete(w http.ResponseWriter, r *http.Request) {
	clientset, err := getClient(r.Header.Get("X-Kube-API-URL"), r.Header.Get("X-Kube-Token"), r.Header.Get("X-Kube-CA"))

	if err != nil {
		log.Println(err)
	}

	vars := mux.Vars(r)
	name := vars["name"]

	if err := clientset.CoreV1().Namespaces().Delete(name, &v1.DeleteOptions{}); errors.IsNotFound(err) || err == nil {
		log.Printf("Deleted namespace: %s\n", name)
		var namespaceItem Namespace
		namespaceItem = Namespace{Name: name}
		payload, err := json.Marshal(namespaceItem)
		if err != nil {
			log.Println(err)
		}
		handleSuccess(w, payload)
		return
	} else {
		handleInternalServerError(w, "error deleting namespace", err)
		return
	}
}

func NamespacesNamePut(w http.ResponseWriter, r *http.Request) {
	clientset, err := getClient(r.Header.Get("X-Kube-API-URL"), r.Header.Get("X-Kube-Token"), r.Header.Get("X-Kube-CA"))

	if err != nil {
		panic(err)
	}

	vars := mux.Vars(r)
	name := vars["name"]
	_ = name

	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		panic(err)
	} else {
		log.Println(string(body))
	}

	var n Namespace
	err = json.Unmarshal(body, &n)

	if err != nil {
		log.Println(err)
		handleInternalServerError(w, "client error", err)
		return
	}

	log.Printf("Unmarshalled body to struct")

	namespaceName := n.Spec.Name
	namespaceServiceAccounts := n.Spec.ServiceAccounts

	log.Printf("Attempting to create namespace: %s", namespaceName)

	namespace, err := clientset.CoreV1().Namespaces().Create(&v1.Namespace{
		ObjectMeta: v1.ObjectMeta{
			Name: namespaceName,
		},
	})
	_ = namespace

	if errors.IsAlreadyExists(err) || err == nil {
		log.Printf("Namespace already exists: %s", namespaceName)
	} else {
		handleInternalServerError(w, "error creating namespace", err)
		return
	}

	for _, sa := range namespaceServiceAccounts {
		subject := rbacv1alpha1.Subject{
			Kind:      "ServiceAccount",
			Name:      sa["name"],
			Namespace: "default",
		}

		var subjects []rbacv1alpha1.Subject

		subjects = append(subjects, subject)

		roleRef := rbacv1alpha1.RoleRef{
			APIGroup: "rbac.authorization.k8s.io",
			Kind:     "ClusterRole",
			Name:     "cluster-admin",
		}

		roleBinding := rbacv1alpha1.RoleBinding{
			Subjects: subjects,
			RoleRef:  roleRef,
			ObjectMeta: v1.ObjectMeta{
				Name: sa["name"] + "-cluster-admin-" + namespaceName,
			},
		}

		roleBindingReponse, err := clientset.Rbac().RoleBindings("default").Create(&roleBinding)
		_ = roleBindingReponse

		if errors.IsAlreadyExists(err) || err == nil {
			log.Printf("Created role binding: %s-cluster-admin-%s", sa["name"], namespaceName)
		} else {
			log.Printf("Failed to create role binding: %s-cluster-admin-%s", sa["name"], namespaceName)
			handleInternalServerError(w, "error creating rolebinding for namespace", err)
			return
		}
	}
	var namespaceItem Namespace

	namespaceItem = Namespace{Name: namespaceName, Spec: &NamespaceSpec{Name: namespaceName, ServiceAccounts: namespaceServiceAccounts}}
	payload, err := json.Marshal(namespaceItem)
	if err != nil {
		log.Println(err)
	}
	handleSuccess(w, payload)
	return
}

func ServiceAccountsNamespaceGet(w http.ResponseWriter, r *http.Request) {
	clientset, err := getClient(r.Header.Get("X-Kube-API-URL"), r.Header.Get("X-Kube-Token"), r.Header.Get("X-Kube-CA"))

	vars := mux.Vars(r)
	namespace := vars["namespace"]

	if namespace == "" {
		namespace = "default"
	}
	namespaceCheck, err := clientset.CoreV1().Namespaces().Get(namespace)
	_ = namespaceCheck

	if errors.IsNotFound(err) {
		log.Printf("Namespace: %s not found\n", namespace)
		handleNotFoundError(w, err)
		return
	}

	serviceAccounts, err := clientset.CoreV1().ServiceAccounts(namespace).List(v1.ListOptions{})
	_ = serviceAccounts

	if errors.IsNotFound(err) {
		log.Printf("Service account not found\n")
		handleNotFoundError(w, err)
		return
	}

	if err != nil {
		handleInternalServerError(w, "error getting service account", err)
		return
	}

	var serviceAccountList []string
	for _, sa := range serviceAccounts.Items {
		serviceAccountList = append(serviceAccountList, sa.Name)
	}

	payload, err := json.Marshal(serviceAccountList)

	if err != nil {
		log.Println(err)
	}

	log.Printf("Listing service accounts for namespace: %s\n", namespace)
	handleSuccess(w, payload)
	return
}

func ServiceAccountsNamespaceNameDelete(w http.ResponseWriter, r *http.Request) {
	clientset, err := getClient(r.Header.Get("X-Kube-API-URL"), r.Header.Get("X-Kube-Token"), r.Header.Get("X-Kube-CA"))

	if err != nil {
		log.Println(err)
	}

	vars := mux.Vars(r)
	name := vars["name"]
	namespace := vars["namespace"]

	if namespace == "" {
		namespace = "default"
	}

	if err := clientset.CoreV1().ServiceAccounts(namespace).Delete(name, &v1.DeleteOptions{}); errors.IsNotFound(err) || err == nil {
		var serviceAccount ServiceAccount
		serviceAccount = ServiceAccount{Name: name}
		payload, err := json.Marshal(serviceAccount)
		if err != nil {
			log.Println(err)
		}
		log.Printf("Deleted service account: %s from namespace: %s\n", name, namespace)
		handleSuccess(w, payload)
		return
	} else if err != nil {
		handleInternalServerError(w, "error deleting service account", err)
		return
	}
}

func ServiceAccountsNamespaceNameGet(w http.ResponseWriter, r *http.Request) {
	clientset, err := getClient(r.Header.Get("X-Kube-API-URL"), r.Header.Get("X-Kube-Token"), r.Header.Get("X-Kube-CA"))

	vars := mux.Vars(r)
	name := vars["name"]
	namespace := vars["namespace"]

	if namespace == "" {
		namespace = "default"
	}

	serviceAccount, err := clientset.CoreV1().ServiceAccounts(namespace).Get(name)
	_ = serviceAccount

	if errors.IsNotFound(err) {
		log.Printf("Service account %s not found\n", name)
		handleNotFoundError(w, err)
		return
	}

	if err != nil {
		handleInternalServerError(w, "error getting service account", err)
		return
	}

	secret, err := clientset.CoreV1().Secrets(namespace).Get(serviceAccount.Secrets[0].Name)
	_ = secret

	if err != nil {
		log.Printf("Error getting service account token for %s\n", name)
		log.Println(err)
	}

	// TODO: add token to response
	// ServiceAccountSpec{Name: name, Token: string(secret.Data["token"])}

	var serviceAccountItem ServiceAccount
	serviceAccountItem = ServiceAccount{Name: name}
	payload, err := json.Marshal(serviceAccountItem)
	if err != nil {
		log.Println(err)
	}
	log.Printf("Found service account: %s\n", name)
	handleSuccess(w, payload)
	return
}

func ServiceAccountsNamespaceNamePut(w http.ResponseWriter, r *http.Request) {
	clientset, err := getClient(r.Header.Get("X-Kube-API-URL"), r.Header.Get("X-Kube-Token"), r.Header.Get("X-Kube-CA"))

	vars := mux.Vars(r)
	name := vars["name"]
	namespace := vars["namespace"]

	serviceAccount, err := clientset.CoreV1().ServiceAccounts(namespace).Create(&v1.ServiceAccount{
		ObjectMeta: v1.ObjectMeta{
			Name: name,
		},
	})
	_ = serviceAccount

	if errors.IsAlreadyExists(err) || err == nil {
		// TODO: add token to response
		// ServiceAccountSpec{Name: name, Token: string(secret.Data["token"])}
		var serviceAccountItem ServiceAccount
		serviceAccountItem = ServiceAccount{Name: name}
		payload, err := json.Marshal(serviceAccountItem)
		if err != nil {
			log.Println(err)
		}
		log.Printf("Created service account: %s in namespace: %s\n", name, namespace)
		handleSuccess(w, payload)
		return
	} else {
		log.Println(err)
		handleInternalServerError(w, "error creating service account", err)
		return
	}
}
