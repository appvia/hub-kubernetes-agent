/*
 * hub-kubernetes-agent
 *
 * an agent used to provision and configure Kubernetes resources
 *
 * API version: v1beta
 * Contact: support@appvia.io
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"encoding/base64"
	"encoding/json"
	"log"
	"net/http"

	"github.com/bitly/go-simplejson"
	"github.com/gorilla/mux"
	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"

	corev1 "k8s.io/api/core/v1"
	rbac "k8s.io/api/rbac/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var clientset *kubernetes.Clientset

func getClient(server, token, caCert string) (*kubernetes.Clientset, error) {
	decodedCert, err := base64.StdEncoding.DecodeString(caCert)

	if err != nil {
		log.Println("decode error:", err)
		return nil, err
	}

	config := &rest.Config{
		Host:            server,
		BearerToken:     token,
		TLSClientConfig: rest.TLSClientConfig{CAData: decodedCert},
	}

	client, err := kubernetes.NewForConfig(config)
	_ = client

	if err != nil {
		return nil, err
	}

	return kubernetes.NewForConfig(config)
}

func handleSuccess(w http.ResponseWriter, payload []byte) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	w.Write(payload)
}

func handleInternalServerError(w http.ResponseWriter, reason string, err error) {
	log.Println(w, err.Error())
	json := simplejson.New()
	json.Set("reason", reason)
	json.Set("detail", err)
	payload, err := json.MarshalJSON()
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	http.Error(w, string(payload), http.StatusInternalServerError)
}

func handleNotFoundError(w http.ResponseWriter, err error) {
	log.Println(w, err.Error())
	json := simplejson.New()
	json.Set("reason", "not found")
	json.Set("detail", err)
	payload, err := json.MarshalJSON()
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	http.Error(w, string(payload), http.StatusNotFound)
}

func NamespacesList(w http.ResponseWriter, r *http.Request) {
	clientset, err := getClient(r.Header.Get("X-Kube-API-URL"), r.Header.Get("X-Kube-Token"), r.Header.Get("X-Kube-CA"))

	if err != nil {
		log.Println(err)
	}

	namespaces, err := clientset.CoreV1().Namespaces().List(metav1.ListOptions{})

	if err != nil {
		handleInternalServerError(w, "error listing namespaces", err)
	} else {
		var namespaceList []Namespace
		for _, namespace := range namespaces.Items {
			namespaceList = append(namespaceList, Namespace{Name: namespace.Name})
		}
		payload, err := json.Marshal(namespaceList)
		if err != nil {
			log.Println(err)
		}
		handleSuccess(w, payload)
	}
}

func NamespacesNameGet(w http.ResponseWriter, r *http.Request) {
	clientset, err := getClient(r.Header.Get("X-Kube-API-URL"), r.Header.Get("X-Kube-Token"), r.Header.Get("X-Kube-CA"))

	vars := mux.Vars(r)
	name := vars["name"]
	namespace, err := clientset.CoreV1().Namespaces().Get(name, metav1.GetOptions{})
	json := simplejson.New()

	if err != nil {
		if errors.IsNotFound(err) {
			handleNotFoundError(w, err)
		} else {
			handleInternalServerError(w, "Error getting namespace", err)
		}
	} else {
		json.Set("name", name)
		log.Printf("Found namespace: %s\n", name)

		_ = namespace

		w.Header().Set("Content-Type", "application/json; charset=UTF-8")
		w.WriteHeader(http.StatusOK)

		payload, err := json.MarshalJSON()
		if err != nil {
			log.Println(err)
		}
		w.Write(payload)
	}
}

func NamespacesNameDelete(w http.ResponseWriter, r *http.Request) {
	clientset, err := getClient(r.Header.Get("X-Kube-API-URL"), r.Header.Get("X-Kube-Token"), r.Header.Get("X-Kube-CA"))

	if err != nil {
		log.Println(err)
	}

	vars := mux.Vars(r)
	name := vars["name"]

	json := simplejson.New()

	deletePolicy := metav1.DeletePropagationForeground

	if err := clientset.CoreV1().Namespaces().Delete(name, &metav1.DeleteOptions{
		PropagationPolicy: &deletePolicy,
	}); errors.IsNotFound(err) || err == nil {
		json.Set("name", name)
		payload, err := json.MarshalJSON()
		if err != nil {
			log.Println(err)
		}
		log.Printf("Deleted namespace: %s\n", name)
		handleSuccess(w, payload)
	} else if err != nil {
		handleInternalServerError(w, "namespace not found", err)
	}
}

func NamespacesNamePut(w http.ResponseWriter, r *http.Request) {
	clientset, err := getClient(r.Header.Get("X-Kube-API-URL"), r.Header.Get("X-Kube-Token"), r.Header.Get("X-Kube-CA"))

	if err != nil {
		panic(err)
	}

	vars := mux.Vars(r)
	name := vars["name"]

	decoder := json.NewDecoder(r.Body)
	var s GlobalServiceAccount
	decoder.Decode(&s)

	globalServiceAccountName := s.Name

	namespace, err := clientset.CoreV1().Namespaces().Create(&corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: name,
		},
	})
	_ = namespace

	json := simplejson.New()

	if errors.IsAlreadyExists(err) || err == nil {

		subject := rbac.Subject{
			Kind:      "ServiceAccount",
			APIGroup:  "",
			Name:      globalServiceAccountName,
			Namespace: "default",
		}

		var subjects []rbac.Subject

		subjects = append(subjects, subject)

		roleRef := rbac.RoleRef{
			APIGroup: "rbac.authorization.k8s.io",
			Kind:     "ClusterRole",
			Name:     "cluster-admin",
		}

		roleBinding := rbac.RoleBinding{
			Subjects: subjects,
			RoleRef:  roleRef,
			ObjectMeta: metav1.ObjectMeta{
				Name: globalServiceAccountName + "-cluster-admin-" + name,
			},
		}

		roleBindingReponse, err := clientset.RbacV1().RoleBindings(name).Create(&roleBinding)
		_ = roleBindingReponse

		if errors.IsAlreadyExists(err) || err == nil {
			json.Set("name", name)
			payload, err := json.MarshalJSON()
			if err != nil {
				log.Println(err)
			}
			log.Printf("Created namespace: %s\n", name)
			log.Printf("Created role binding: %s\n", globalServiceAccountName+"-cluster-admin-"+name)
			handleSuccess(w, payload)
		} else {
			handleInternalServerError(w, "error creating rolebinding for namespace", err)
		}
	} else {
		handleInternalServerError(w, "error creating namespace", err)
	}
}

func ServiceAccountsNamespaceGet(w http.ResponseWriter, r *http.Request) {
	clientset, err := getClient(r.Header.Get("X-Kube-API-URL"), r.Header.Get("X-Kube-Token"), r.Header.Get("X-Kube-CA"))

	vars := mux.Vars(r)
	namespace := vars["namespace"]

	if namespace == "" {
		namespace = "default"
	}
	namespaceCheck, err := clientset.CoreV1().Namespaces().Get(namespace, metav1.GetOptions{})
	_ = namespaceCheck

	if errors.IsNotFound(err) {
		log.Printf("Namespace: %s not found\n", namespace)
		handleNotFoundError(w, err)
		return
	}

	serviceAccounts, err := clientset.CoreV1().ServiceAccounts(namespace).List(metav1.ListOptions{})
	_ = serviceAccounts

	json := simplejson.New()

	if errors.IsNotFound(err) {
		log.Printf("Service account not found\n")
		handleNotFoundError(w, err)
	} else if err != nil {
		handleInternalServerError(w, "error getting service account", err)
	} else {
		var serviceAccountList []string
		for _, sa := range serviceAccounts.Items {
			serviceAccountList = append(serviceAccountList, sa.Name)
		}
		json.Set("service-accounts", serviceAccountList)
		payload, err := json.MarshalJSON()
		if err != nil {
			log.Println(err)
		}
		log.Printf("Listing service accounts for namespace: %s\n", namespace)
		handleSuccess(w, payload)
	}
}

func ServiceAccountsNamespaceNameDelete(w http.ResponseWriter, r *http.Request) {
	clientset, err := getClient(r.Header.Get("X-Kube-API-URL"), r.Header.Get("X-Kube-Token"), r.Header.Get("X-Kube-CA"))

	if err != nil {
		log.Println(err)
	}

	vars := mux.Vars(r)
	name := vars["name"]
	namespace := vars["namespace"]

	if namespace == "" {
		namespace = "default"
	}
	json := simplejson.New()

	deletePolicy := metav1.DeletePropagationForeground
	if err := clientset.CoreV1().ServiceAccounts(namespace).Delete(name, &metav1.DeleteOptions{
		PropagationPolicy: &deletePolicy,
	}); errors.IsNotFound(err) || err == nil {
		json.Set("name", name)
		payload, err := json.MarshalJSON()
		if err != nil {
			log.Println(err)
		}
		log.Printf("Deleted service account: %s from namespace: %s\n", name, namespace)
		handleSuccess(w, payload)
	} else if err != nil {
		handleInternalServerError(w, "error deleting service account", err)
	}
}

func ServiceAccountsNamespaceNameGet(w http.ResponseWriter, r *http.Request) {
	clientset, err := getClient(r.Header.Get("X-Kube-API-URL"), r.Header.Get("X-Kube-Token"), r.Header.Get("X-Kube-CA"))

	vars := mux.Vars(r)
	name := vars["name"]
	namespace := vars["namespace"]

	if namespace == "" {
		namespace = "default"
	}

	serviceAccount, err := clientset.CoreV1().ServiceAccounts(namespace).Get(name, metav1.GetOptions{})
	_ = serviceAccount

	json := simplejson.New()

	if errors.IsNotFound(err) {
		log.Printf("Service account %s not found\n", name)
		handleNotFoundError(w, err)
	} else if err != nil {
		handleInternalServerError(w, "error getting service account", err)
	} else {
		json.Set("name", name)
		secret, err := clientset.CoreV1().Secrets(namespace).Get(serviceAccount.Secrets[0].Name, metav1.GetOptions{})
		if err != nil {
			log.Printf("Error getting service account token for %s\n", name)
			log.Println(err)
		} else {
			json.Set("token", string(secret.Data["token"]))
		}
		payload, err := json.MarshalJSON()
		if err != nil {
			log.Println(err)
		}
		log.Printf("Found service account: %s\n", name)
		handleSuccess(w, payload)
	}
}

func ServiceAccountsNamespaceNamePut(w http.ResponseWriter, r *http.Request) {
	clientset, err := getClient(r.Header.Get("X-Kube-API-URL"), r.Header.Get("X-Kube-Token"), r.Header.Get("X-Kube-CA"))

	vars := mux.Vars(r)
	name := vars["name"]
	namespace := vars["namespace"]

	serviceAccount, err := clientset.CoreV1().ServiceAccounts(namespace).Create(&corev1.ServiceAccount{
		ObjectMeta: metav1.ObjectMeta{
			Name: name,
		},
	})
	_ = serviceAccount

	json := simplejson.New()

	if errors.IsAlreadyExists(err) || err == nil {
		json.Set("name", name)
		if err != nil {
			log.Println(err)
		}
		serviceAccount, err := clientset.CoreV1().ServiceAccounts(namespace).Get(name, metav1.GetOptions{})
		_ = serviceAccount
		secret, err := clientset.CoreV1().Secrets(namespace).Get(serviceAccount.Secrets[0].Name, metav1.GetOptions{})
		if err != nil {
			log.Printf("Error getting service account token for %s\n", name)
			log.Println(err)
		} else {
			json.Set("token", string(secret.Data["token"]))
		}
		payload, err := json.MarshalJSON()
		log.Printf("Created service account: %s in namespace: %s\n", name, namespace)
		handleSuccess(w, payload)
	} else if err != nil {
		log.Println(err)
		handleInternalServerError(w, "error creating service account", err)
	}
}
